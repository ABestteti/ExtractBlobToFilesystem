// Bibliotecas do programa:
#include <stdio.h>
#include <string.h>
#include <oci.h>
#include <stdlib.h>
#include <ctype.h>
#include <time.h>

// Versão do programa:
#define VERSAO_PROGRAMA "14.03.2012"

EXEC SQL INCLUDE ORACA;

EXEC SQL BEGIN DECLARE SECTION;

/**
*   Maior tamanho possível de um arquivo dentro
* de uma coluna BLOB em bytes (4GB = 4294967296
* bytes ).
*/
#define MAX_TAMANHO_BLOB 4294967296

// Tamanho do buffer para obter a mensagem de erro do banco:
#define TAMANHO_BUFFER_MENSAGEM 1024

// Tamanho de caracteres possíveis em um nome de usuário:
#define UNAME_LEN 30

// Tamanho de caracteres possíveis em uma senha:
#define PWD_LEN 30

// Variável para obter o nome do usuário:
VARCHAR username[UNAME_LEN];

// Variável para obter a senha do usuário:
VARCHAR password[PWD_LEN];

EXEC SQL END DECLARE SECTION;

EXEC SQL include sqlca;

void proc_cria_log(string, unsigned short);
void proc_connect(unsigned short);
void proc_connect_error(unsigned short);
extern void sqlglm(char*, size_t*, size_t*);
int main(int, char **);


/**************************************
*  Função para gerar o log dos erros *
**************************************/
void proc_cria_log(string mensagem_execucao, unsigned short ponto_execucao)
{
    // Variável para trabalhar com o arquivo de log:
    FILE * arquivo_log;

    // Cabeçalho do arquivo de log:
    string cabecalho = "Ação Sistemas de Informática LTDA\nSUP8110 - Programa para anexar e desanexar arquivos do sistema de suporte.\nDireitos Autorais (c) 1994-2012";

    // Parâmetros para a execução do programa:
    string parametros = "Parâmetros para a execução do programa:\n\tSUP8110 {usuario@host} {senha} {0 | 1} {aten_repe_soli_numero} {aten_repe_pape_cod} {aten_repe_pess_cod} {aten_dt_ini_atend} {seq}";

    // Nome do arquivo de log do programa:
    char nome_arquivo_log[32];

    // Variáveis para obter a data e hora de execução do programa:
    time_t rawtime;
    struct tm* timeinfo;

    // Variável para obter as informações de data e hora do sistema convertidos em caractere:
    char aux[16];

    // Variáveis para obter a mensagem de erro do banco:
    int tamanho_buffer = TAMANHO_BUFFER_MENSAGEM;
    char buffer_mensagem_banco[TAMANHO_BUFFER_MENSAGEM];
    int tamanho_mensagem_banco;


    time(&rawtime);
    timeinfo = localtime(&rawtime);

    // Monta o nome do arquivo de log:
    memset(nome_arquivo_log, '\0', 32);
    strcat(nome_arquivo_log, "SUP8110-");

    // Obtém o ano de execução do programa:
    sprintf(aux, "%04d\0", timeinfo->tm_year + 1900);
    strcat(nome_arquivo_log, aux);
    strcat(nome_arquivo_log, "-");

    // Obtém o mês de execução do programa:
    sprintf(aux, "%02d\0", timeinfo->tm_mon + 1);
    strcat(nome_arquivo_log, aux);
    strcat(nome_arquivo_log, "-");

    // Obtém o dia de execução do programa:
    sprintf(aux, "%02d\0", timeinfo->tm_mday);
    strcat(nome_arquivo_log, aux);
    strcat(nome_arquivo_log, "-");

    // Obtém a hora de execução do programa:
    sprintf(aux, "%02d\0", timeinfo->tm_hour);
    strcat(nome_arquivo_log, aux);
    strcat(nome_arquivo_log, "-");

    // Obtém a hora de execução do programa:
    sprintf(aux, "%02d\0", timeinfo->tm_min);
    strcat(nome_arquivo_log, aux);
    strcat(nome_arquivo_log, "-");

    // Obtém a hora de execução do programa:
    sprintf(aux, "%02d\0", timeinfo->tm_sec);
    strcat(nome_arquivo_log, aux);

    // Informa o sufixo do arquivo de log:
    strcat(nome_arquivo_log, ".LOG");

    EXEC SQL WHENEVER SQLERROR CONTINUE;

    // Obtém a mensagem do erro ocorrido do banco de dados (caso exista):
    sqlglm(buffer_mensagem_banco, &tamanho_buffer, &tamanho_mensagem_banco);
    buffer_mensagem_banco[tamanho_mensagem_banco] = '\0';

    // Abre o arquivo de log:
    arquivo_log = fopen(nome_arquivo_log, "w");

    // Verifica se o arquivo de log foi aberto com sucesso:
    if (arquivo_log == NULL)
    {
        printf("Não foi possivel criar arquivo de log.\n");
        exit(1);
    }

    /**
    *   Informa no arquivo de log o cabeçalho, a versão, a data
    * e hora da execução e os parâmetros que devem ser utilizados
    * no programa:
    */
    fputs(cabecalho, arquivo_log);
    fputs("\n", arquivo_log);
    fputs("Versão do programa: ", arquivo_log);
    fputs(VERSAO_PROGRAMA, arquivo_log);
    fputs("\n", arquivo_log);
    fputs("\n", arquivo_log);

    // Verifica se o programa foi concluído com sucesso.
    if (ponto_execucao == 0)
    {
        fputs(mensagem_execucao, arquivo_log);
        fputs("\n", arquivo_log);
        fputs("Programa \"SUP8110\" concluído com sucesso.", arquivo_log);
    }
    // Caso tenha ocorrido um erro durante a execução do programa:
    else
    {
        // Informa o ponto onde o programa foi abortado:
        fputs("Programa abortado no ponto ", arquivo_log);
        sprintf(aux, "%d.\n", ponto_execucao);
        fputs(aux, arquivo_log);

        // Se há uma mensagem de erro do programa, informa no log:
        if (strcmp(mensagem_execucao, "") != 0)
        {
            fputs(mensagem_execucao, arquivo_log);
            fputs("\n", arquivo_log);
        }

        // Se há uma mensagem de erro do banco, informa no log:
        if (tamanho_mensagem_banco > 0)
        {
            fputs("Mensagem de erro do banco de dados: ", arquivo_log);
            fputs(buffer_mensagem_banco, arquivo_log);
            fputs("\n", arquivo_log);
        }

    }

    // Fecha o arquivo de log do programa:
    fclose(arquivo_log);

    if (ponto_execucao == 0) exit(0);
    else exit(1);
}


/*********************************
* Função para conectar no banco *
*********************************/
void proc_connect(unsigned short ponto_execucao)
{
    EXEC SQL WHENEVER SQLERROR DO proc_connect_error(ponto_execucao);
    EXEC SQL CONNECT :username IDENTIFIED BY :password;

    EXEC SQL WHENEVER SQLERROR CONTINUE;
    EXEC SQL COMMIT WORK;
}

/************************************************
* Função de tratamento de erros para a conexão *
************************************************/
void proc_connect_error(unsigned short ponto_execucao)
{
    string mensagem_execucao = "Erro durante a conexão com o banco de dados.";
    proc_cria_log(mensagem_execucao, ponto_execucao);
}


int main(int argc, char *argv[])
{
    // Variável para indicar o ponto de execução do programa:
    unsigned short ponto_execucao = 0;

    // Variável para informar a mensagem de execução do programa:
    string mensagem_execucao = "";

    // Variável para manipular o arquivo a ser lido ou escrito:
    FILE *arquivo;

    EXEC SQL BEGIN DECLARE SECTION;

    /**
    *   Valor da variável calculada de acordo com
    * o tamanho médio dos arquivos anexados no
    * sistema de suporte até o dia 07/03/2012.
    */
#define TAMANHO_BUFFER 278353

    // Variável para manipular a coluna BLOB da tabela "ANEXOS":
    OCIBlobLocator *v_texto;

    // Buffer para manipulação de dados entre o blob e o arquivo:
    unsigned char buffer[TAMANHO_BUFFER];

    EXEC SQL VAR buffer IS RAW(TAMANHO_BUFFER);

    // Variável para armazenar o total de leituras que o buffer deverá realizar:
    unsigned int total_leituras_buffer;

    // Variável para armazenar o tamanho restante do arquivo após as leituras do buffer:
    int tamanho_final_arquivo = 0;

    // Variável para armazenar o tamanho do blob em bytes:
    int tamanho_blob;

    // Variável para informar o tamanho máximo de um arquivo BLOB:
    unsigned int tamanho_maximo_blob = MAX_TAMANHO_BLOB - 1;

    // Variável para armazenar o nome do arquivo obtido da tabela "ANEXOS":
    VARCHAR v_nome_arquivo[255];

    // Variável para armazenar a data de início do atendimento ao qual o arquivo está anexado:
    VARCHAR v_aten_dt_ini_atend[19];

    // Variável para armaznear o número da solicitação:
    int v_aten_repe_soli_numero;

    // Variável para armazenar o código do papel do atendente:
    int v_aten_repe_pape_cod;

    // Variável para armazenar o código do atendente:
    int v_aten_repe_pess_cod;

    // Variável para armazenar o código sequencial do arquivo no atendimento:
    int seq;

    /**
    *   Variável para armazenar o tamanho máximo do buffer
    * Obs: Necessário porque os comandos do Pro*C devem receber
    * o tamanho do buffer através de uma variável.
    */
    unsigned int tamanho_buffer = TAMANHO_BUFFER;

    // Variável para armazenar o tamanho do arquivo:
    unsigned int tamanho_arquivo;

    // Variável para contar o número de leituras do arquivo:
    unsigned int contador = 0;

    EXEC SQL END DECLARE SECTION;

    // Verifica foram passados oito parâmetros para o programa (mais o nome deste) ao todo.
    if (argc != 9)
    {
        ponto_execucao = 1;
        mensagem_execucao = "Erro: São necessarios oito parâmetros para executar este programa.";
        proc_cria_log(mensagem_execucao, ponto_execucao);
    }
    else
    {
        // Verifica se o tipo de dados dos paramêtros estão corretos.
        if
            (
            (isdigit(argv[4][0]) == FALSE) ||
            (isdigit(argv[5][0]) == FALSE) ||
            (isdigit(argv[6][0]) == FALSE) ||
            (isdigit(argv[8][0]) == FALSE)
            )
        {
            ponto_execucao = 2;
            mensagem_execucao = "Erro: Os parâmetros \"aten_repe_soli_numero\", \"aten_repe_pess_cod\", \"aten_repe_pape_cod\" e \"seq\" devem ser numéricos.";
            proc_cria_log(mensagem_execucao, ponto_execucao);
        }
        else
        {
            // Verifica se a data está sendo passada com 19 digitos.   
            if (strlen(argv[7]) != 19)
            {
                ponto_execucao = 3;
                mensagem_execucao = "Erro: O parâmetro \"aten_dt_ini_atend\" deve estar no formato \"DD/MM/YYYY HH24:MI:SS\".";
                proc_cria_log(mensagem_execucao, ponto_execucao);
            }
        }
    }

    // Obtém o nome do usuário:
    strncpy((char *)username.arr, argv[1], UNAME_LEN);
    username.len = strlen((char *)username.arr);

    // Obtém a senha do usuário:
    strncpy((char *)password.arr, argv[2], PWD_LEN);
    password.len = strlen((char *)password.arr);

    // Obtém a data de início de atendimento da solicitação:
    strcpy((char *)v_aten_dt_ini_atend.arr, argv[7]);
    v_aten_dt_ini_atend.len = strlen((char *)v_aten_dt_ini_atend.arr);

    // Obtém o número da solicitação:
    v_aten_repe_soli_numero = atoi(argv[4]);

    // Obtém o código do papel da pessoa:
    v_aten_repe_pape_cod = atoi(argv[5]);

    // Obtém o código da pessoa:
    v_aten_repe_pess_cod = atoi(argv[6]);

    // Obtém o código sequencial do arquivo solicitado:
    seq = atoi(argv[8]);

    ponto_execucao = 4;

    // Solicita a conexão ao banco:
    proc_connect(ponto_execucao);

    // Verifica se foi solicitado uma leitura do banco e escrita no arquivo:
    if (strcmp(argv[3], "0") == 0)
    {
        ponto_execucao = 5;
        EXEC SQL WHENEVER SQLERROR DO proc_cria_log("", ponto_execucao);

        EXEC SQL ALLOCATE : v_texto;

        // Busca o nome e o conteúdo do arquivo solicitado:
        EXEC SQL SELECT
            texto
            , nome_arquivo
            , NVL(dbms_lob.getlength(texto), 0)
            INTO
            :v_texto
            , : v_nome_arquivo
            , : tamanho_blob
            FROM
            anexos
            WHERE
            aten_repe_soli_numero = : v_aten_repe_soli_numero AND
            aten_repe_pape_cod = : v_aten_repe_pape_cod    AND
            aten_repe_pess_cod = : v_aten_repe_pess_cod    AND
            seq = : seq
            AND
            aten_dt_ini_atend = TO_DATE(:v_aten_dt_ini_atend, 'DD/MM/YYYY HH24:MI:SS');

        // Encerra a string do nome do arquivo:
        v_nome_arquivo.arr[v_nome_arquivo.len] = '\0';

        ponto_execucao = 6;

        // Verifica se o arquivo foi encontrado:
        if (strcmp(v_nome_arquivo.arr, argv[4]) == 0)
        {
            mensagem_execucao = "Erro: O arquivo \"";
            strcat(mensagem_execucao, v_nome_arquivo.arr);
            strcat(mensagem_execucao, "\" não foi encontrado.");
            proc_cria_log(mensagem_execucao, ponto_execucao);
        }

        // Verifica se o arquivo está anexado no sistema:
        if (tamanho_blob == 0)
        {
            mensagem_execucao = "Erro: O arquivo \"";
            strcat(mensagem_execucao, v_nome_arquivo.arr);
            strcat(mensagem_execucao, "\" foi cadastrado no sistema, mas seus dados não foram anexados.");
            proc_cria_log(mensagem_execucao, ponto_execucao);
        }

        // Calcula o total de leituras que devem ser feitas pelo buffer:
        total_leituras_buffer = tamanho_blob / TAMANHO_BUFFER;

        // Calcula o tamanho dos dados que sobraram do arquivo após todas as leituras do buffer:
        tamanho_final_arquivo = tamanho_blob % TAMANHO_BUFFER;

        // Abre o arquivo para escrita:
        arquivo = fopen((const char *)v_nome_arquivo.arr, (const char *)"w+b");

        ponto_execucao = 7;

        // Permanece lendo o conteúdo da coluna BLOB até chegar ao seu final:
        while (total_leituras_buffer-- > 0)
        {
            // Lê um bloco do arquivo:
            EXEC SQL LOB READ
                : tamanho_blob
                FROM
                : v_texto
                INTO
                : buffer;

            // Escreve o conteúdo lido do blob no arquivo:
            fwrite((void *)buffer, (size_t)TAMANHO_BUFFER, (size_t)1, arquivo);
        }

        ponto_execucao = 8;

        // Verifica se ainda há algo para ler no final do blob:
        if (tamanho_final_arquivo > 0)
        {
            ponto_execucao = 9;

            // Lê o último bloco de dados do arquivo:
            EXEC SQL LOB READ
                : tamanho_final_arquivo
                FROM
                : v_texto
                INTO
                : buffer;

            // Escreve os últimos bytes do blob no arquivo:
            fwrite((void *)buffer, (size_t)tamanho_final_arquivo, (size_t)1, arquivo);
        }

        ponto_execucao = 10;

        // Fecha o arquivo:
        fclose(arquivo);

        ponto_execucao = 0;

        // Informa a conclusão da leitura do arquivo:
        mensagem_execucao = "Escrita de dados no arquivo \"";
        strcat(mensagem_execucao, v_nome_arquivo.arr);
        strcat(mensagem_execucao, "\" realizada com sucesso.");
        proc_cria_log(mensagem_execucao, ponto_execucao);

    }
    // Verifica se foi solicitada a leitura de um arquivo e sua escrita no banco: 
    else if (strcmp(argv[3], "1") == 0)
    {

        ponto_execucao = 12;

        EXEC SQL ALLOCATE : v_texto;

        // Busca o nome do arquivo:
        EXEC SQL SELECT
            nome_arquivo
            INTO
            : v_nome_arquivo
            FROM
            anexos
            WHERE
            aten_repe_soli_numero = : v_aten_repe_soli_numero                              AND
            aten_repe_pape_cod = : v_aten_repe_pape_cod                                 AND
            aten_repe_pess_cod = : v_aten_repe_pess_cod                                 AND
            seq = : seq                                                  AND
            aten_dt_ini_atend = to_date(:v_aten_dt_ini_atend, 'DD/MM/YYYY HH24:MI:SS');

        // Verifica se o nome do arquivo está cadastrado na tabela "ANEXOS":
        if (strcmp(v_nome_arquivo.arr, argv[4]) == 0)
        {
            mensagem_execucao = "Erro: O arquivo não foi cadastrado na tabela de anexos do sistema.";
            proc_cria_log(mensagem_execucao, ponto_execucao);
        }

        // Encerra a string do nome do arquivo:
        v_nome_arquivo.arr[v_nome_arquivo.len] = '\0';

        ponto_execucao = 13;

        // Abre o arquivo:
        arquivo = fopen((const char *)v_nome_arquivo.arr, (const char *)"rb");

        // Verifica se o arquivo foi aberto com sucesso:
        if (arquivo == NULL)
        {
            mensagem_execucao = "Erro: Não foi possível encontrar o arquivo \"";
            strcat(mensagem_execucao, v_nome_arquivo.arr);
            strcat(mensagem_execucao, "\".");

            proc_cria_log(mensagem_execucao, ponto_execucao);
        }

        // Vai para o final do arquivo:
        fseek(arquivo, 0, SEEK_END);

        // Obtém o tamanho do arquivo:
        tamanho_arquivo = (unsigned int)ftell(arquivo);

        ponto_execucao = 14;

        // Verifica se o tamanho do arquivo não excede a capacidade máxima de arquivos BLOB no sistema:
        if (tamanho_arquivo > MAX_TAMANHO_BLOB)
        {
            mensagem_execucao = "Erro: Limite de 4GB de tamanho excedido pelo arquivo.";
            proc_cria_log(mensagem_execucao, ponto_execucao);
        }

        // Volta o cursor do arquivo para o seu início:
        fseek(arquivo, 0, SEEK_SET);

        ponto_execucao = 15;

        // Calcula o total de leituras que devem ser feitas pelo buffer:
        total_leituras_buffer = tamanho_arquivo / TAMANHO_BUFFER;

        // Calcula o tamanho dos dados que sobraram do arquivo após todas as leituras do buffer:
        tamanho_final_arquivo = tamanho_arquivo % TAMANHO_BUFFER;

        ponto_execucao = 16;

        // Cria um novo blob e obtém um ponteiro para ele na variável "v_texto":
        EXEC SQL UPDATE
            anexos
            SET
            texto = EMPTY_BLOB()
            WHERE
            aten_repe_soli_numero = :v_aten_repe_soli_numero                              AND
            aten_repe_pape_cod = : v_aten_repe_pape_cod                                 AND
            aten_repe_pess_cod = : v_aten_repe_pess_cod                                 AND
            seq = : seq                                                  AND
            aten_dt_ini_atend = to_date(:v_aten_dt_ini_atend, 'DD/MM/YYYY HH24:MI:SS')
            RETURNING
            texto
            INTO
            : v_texto;

        // Faz a leitura do arquivo e o escreve no BLOB:
        while (contador < total_leituras_buffer)
        {

            ponto_execucao = 17;
            // Lê o conteúdo do arquivo:
            fread((void *)buffer, (size_t)sizeof(unsigned char), (size_t)TAMANHO_BUFFER, arquivo);

            ponto_execucao = 18;

            // Se for a primeira escrita no BLOB:
            if (contador == 0)
            {
                ponto_execucao = 19;

                // Verifica se haverão outras escritas no arquivo após esta:
                if (total_leituras_buffer > 1 || tamanho_final_arquivo > 0)
                {
                    ponto_execucao = 20;

                    // Escreve o primeiro bloco no BLOB:
                    EXEC SQL LOB WRITE FIRST
                        : tamanho_arquivo
                        FROM
                        : buffer
                        INTO
                        : v_texto;
                }
                else
                {
                    ponto_execucao = 21;

                    // Escreve um único bloco no BLOB:
                    EXEC SQL LOB WRITE ONE
                        : tamanho_arquivo
                        FROM
                        : buffer
                        INTO
                        : v_texto;
                }
            }
            else
            {
                // Se for o último bloco de dados:
                if ((contador == (total_leituras_buffer - 1)) && (tamanho_final_arquivo == 0))
                {
                    ponto_execucao = 22;

                    // Escreve o último bloco no BLOB:
                    EXEC SQL LOB WRITE LAST
                        : tamanho_arquivo
                        FROM
                        : buffer
                        INTO
                        : v_texto;
                }
                else
                {
                    ponto_execucao = 23;

                    // Escreve o próximo bloco no BLOB:
                    EXEC SQL LOB WRITE NEXT
                        : tamanho_arquivo
                        FROM
                        : buffer
                        INTO
                        : v_texto;
                }
            }

            // Incrementa o contador:
            contador++;
        }

        ponto_execucao = 24;

        // Verifica se ainda existem dados no final do arquivo:    
        if (tamanho_final_arquivo > 0)
        {
            // Lê o que sobrou de dados no final do arquivo:
            fread((void *)buffer, (size_t)sizeof(unsigned char), (size_t)tamanho_final_arquivo, arquivo);

            // Verifica se foram escritos dados previamente no arquivo:
            if (total_leituras_buffer > 0)
            {
                ponto_execucao = 25;

                // Escreve o conteúdo no BLOB:
                EXEC SQL LOB WRITE LAST
                    : tamanho_final_arquivo
                    FROM
                    : buffer
                    INTO
                    : v_texto;
            }
            else
            {
                ponto_execucao = 26;

                // Escreve o conteúdo no BLOB:
                EXEC SQL LOB WRITE ONE
                    : tamanho_final_arquivo
                    FROM
                    : buffer
                    INTO
                    : v_texto;
            }
        }

        ponto_execucao = 27;

        // Fecha o arquivo:
        fclose(arquivo);

        ponto_execucao = 28;

        // Executa o "commit" dos dados:    
        EXEC SQL COMMIT WORK RELEASE;

        ponto_execucao = 0;
        mensagem_execucao = "Leitura de dados do arquivo \"";
        strcat(mensagem_execucao, v_nome_arquivo.arr);
        strcat(mensagem_execucao, "\" realizada com sucesso.");
        proc_cria_log(mensagem_execucao, ponto_execucao);
    }

    exit(0);
}